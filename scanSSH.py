import socket
import argparse
import ipaddress
import threading
from queue import Queue

def is_open(ip, port, timeout, retries=3):
    
    for attempt in range(retries):
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
            sock.settimeout(timeout)
            try:
                sock.connect((ip, port))
                return True
            except:
                if attempt == retries - 1:
                    return False

def retrieve_ssh_banner(ip, port, timeout, retries=3):
  
    for attempt in range(retries):
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
                sock.settimeout(timeout)
                sock.connect((ip, port))
                banner = sock.recv(1024).decode().strip()
                return banner
        except Exception as e:
            if attempt == retries - 1:
                return str(e)

def scan_for_vulnerability(ip, port, timeout, custom_banners, results, verbose, retries=3):
   
    if not is_open(ip, port, timeout, retries):
        results.put((ip, port, 'closed', "Port closed"))
        return

    banner = retrieve_ssh_banner(ip, port, timeout, retries)
    if verbose:
        print(f"[*] Retrieved banner from {ip}: {banner}")

    if "SSH-2.0-OpenSSH" not in banner:
        results.put((ip, port, 'failed', f"Failed to retrieve SSH banner: {banner}"))
        return

    vulnerable_versions = {
        'SSH-2.0-OpenSSH_8.5p1', 'SSH-2.0-OpenSSH_8.6p1', 'SSH-2.0-OpenSSH_8.7p1',
        'SSH-2.0-OpenSSH_8.8p1', 'SSH-2.0-OpenSSH_8.9p1', 'SSH-2.0-OpenSSH_9.0p1',
        'SSH-2.0-OpenSSH_9.1p1', 'SSH-2.0-OpenSSH_9.2p1', 'SSH-2.0-OpenSSH_9.3p1',
        'SSH-2.0-OpenSSH_9.4p1', 'SSH-2.0-OpenSSH_9.5p1', 'SSH-2.0-OpenSSH_9.6p1',
        'SSH-2.0-OpenSSH_9.7p1'
    }

    if any(version in banner for version in vulnerable_versions) or any(custom_banner in banner for custom_banner in custom_banners):
        results.put((ip, port, 'vulnerable', f"(running {banner})"))
    else:
        results.put((ip, port, 'not_vulnerable', f"(running {banner})"))

def worker(queue, port, timeout, custom_banners, results, verbose, retries):
   
    while True:
        ip = queue.get()
        if ip is None:
            break
        scan_for_vulnerability(ip, port, timeout, custom_banners, results, verbose, retries)
        queue.task_done()

def main():
    parser = argparse.ArgumentParser(description="R4Tw1z: OpenSSH Vulnerability Scanner")
    parser.add_argument("targets", nargs='+', help="IP addresses, domain names, file paths with IPs, or CIDR ranges.")
    parser.add_argument("--port", type=int, default=22, help="Port number to check (default: 22).")
    parser.add_argument("-t", "--timeout", type=float, default=1.0, help="Connection timeout in seconds (default: 1 second).")
    parser.add_argument("-w", "--workers", type=int, default=10, help="Number of worker threads (default: 10).")
    parser.add_argument("-o", "--output", type=str, help="File to save the scan results.")
    parser.add_argument("-c", "--custom_banners", nargs='*', default=[], help="Custom SSH banners to check for vulnerabilities.")
    parser.add_argument("-v", "--verbose", action="store_true", help="Enable verbose mode for detailed logging.")
    parser.add_argument("-r", "--retries", type=int, default=3, help="Number of retries for connections (default: 3).")

    args = parser.parse_args()
    targets = args.targets
    port = args.port
    timeout = args.timeout
    num_workers = args.workers
    output_file = args.output
    custom_banners = args.custom_banners
    verbose = args.verbose
    retries = args.retries

    ip_list = []
    for target in targets:
        try:
            with open(target, 'r') as file:
                ip_list.extend(file.read().splitlines())
        except IOError:
            if '/' in target:
                try:
                    network = ipaddress.ip_network(target, strict=False)
                    ip_list.extend([str(ip) for ip in network.hosts()])
                except ValueError:
                    print(f"‚ùå [-] Invalid CIDR notation: {target}")
            else:
                ip_list.append(target)

    result_queue = Queue()
    ip_queue = Queue()

    for ip in ip_list:
        ip_queue.put(ip.strip())

    threads = []
    for _ in range(num_workers):
        thread = threading.Thread(target=worker, args=(ip_queue, port, timeout, custom_banners, result_queue, verbose, retries))
        thread.start()
        threads.append(thread)

    ip_queue.join()

    for _ in range(num_workers):
        ip_queue.put(None)
    for thread in threads:
        thread.join()

    total_scanned = len(ip_list)
    closed_ports = 0
    non_vulnerable = []
    vulnerable_servers = []

    while not result_queue.empty():
        ip, port, status, message = result_queue.get()
        if status == 'closed':
            closed_ports += 1
        elif status == 'vulnerable':
            vulnerable_servers.append((ip, message))
        elif status == 'not_vulnerable':
            non_vulnerable.append((ip, message))
        else:
            print(f" [!] Server at {ip}:{port} is {message}")

    if output_file:
        with open(output_file, 'w') as f:
            f.write(f"Servers not vulnerable: {len(non_vulnerable)}\n")
            for ip, msg in non_vulnerable:
                f.write(f"   [+] Server at {ip} {msg}\n")
            f.write(f"\nServers likely vulnerable: {len(vulnerable_servers)}\n")
            for ip, msg in vulnerable_servers:
                f.write(f"   [+] Server at {ip} {msg}\n")
            f.write(f"\nServers with port 22 closed: {closed_ports}\n")
            f.write(f"\nTotal scanned targets: {total_scanned}\n")
    else:
        print(f"\nServers not vulnerable: {len(non_vulnerable)}")
        for ip, msg in non_vulnerable:
            print(f"   [+] Server at {ip} {msg}")

        print(f"\nServers likely vulnerable: {len(vulnerable_servers)}")
        for ip, msg in vulnerable_servers:
            print(f"   [+] Server at {ip} {msg}")

        print(f"\nServers with port 22 closed: {closed_ports}")
        print(f"\nTotal scanned targets: {total_scanned}\n")

if __name__ == "__main__":
    main()
